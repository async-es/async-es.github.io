<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">

    <link rel="stylesheet" href="async.css">

    <script src="http://code.jquery.com/jquery-2.0.3.min.js"></script>
    <script src="traceur/traceur.js"></script>
    <script src="traceur/bootstrap.js"></script>
  </head>

  <body>
    <div class="navbar navbar-default">

      <div class="navbar-header">
        <a class="navbar-brand" href="https://github.com/async-es/async-es">async.es</a>
      </div>
      
    </div>

    <div class="container">

      <div class="jumbotron">
        <h1>Straightforward Async Javascript</h1>
        <p class="lead">
          Let's say you want to build an autocomplete search field for Wikipedia.
        </p>

        <p>
          As the user types characters, the program should get results from Wikipedia
          and display them below the input field.
        </p>

        <div class="well well-lg">
          Give it a try:

          <div id="search">
            <input id="searchtext" class="form-control" placeholder="search"></input>
            <div id="results"></div>
          </div>
        </div>

        <span class="label label-success">
          Async.js is a tiny library that makes it easy to write asynchronous programs
          in JavaScript
        </span>

      </div>


      <div id="problem" class="panel panel-primary">
        <div class="panel-heading">
          <h4>1. problem</h4>
        </div>

        <div class="panel-body">

          <p>
            Because you want a pleasant user experience you decide the program
            should:
          </p>
          <dl class="dl-horizontal">
            <dt>responsive</dt>
            <dd>display results as the user enters characters</dd>

            <dt>correct</dt>
            <dd>
              display the correct results, even if API requests return out of order
              (e.g. "abso" might return before "abs" does)
            </dd>

            <dt>efficient</dt>
            <dd>not make unnecessary API requests if the user types quickly</dd>

            <dt>unique</dt>
            <dd>
              not issue multiple consecutive API requests for the same search input (the keyup
              event might fire without the text changing)
            </dd>


            <dt>minimum length</dt>
            <dd>only give suggestions once more than 2 characters are entered</dd>

          </dl>

        </div>
      </div>

      <div id="program-structure" class="panel panel-primary">
        <div class="panel-heading">
          <h4>2. program structure</h4>
        </div>

        <div class="panel-body">
          Since listening to key input and making HTTP requests involve callbacks you
          suspect the general shape of your program will look something like:

          <pre>
            keyup(function(event) {
                $.getJSON(searchUrl + input.text, function(data) {
                    displayResults(data);
                });        
            });
          </pre>

          But crafting a proper solution that deals with out of order results,
          making effecient API requests, and keeping the UI responsive becomes
          tricky because you need to orchestrate control flow across asynchronous callbacks.

          Is there another way?
        </div>
      </div>

      <div id="pseudocode" class="panel panel-primary">
        <div class="panel-heading">
          <h4>3. pseudocode</h4>
        </div>

        <div class="panel-body">
          <p>
            It is often useful to outline, without too much specificity, the algorithm
            that solves the problem in a way that is programming language agnostic.
          </p>

          <p>
            Ignoring asynchrony, that might looking something like:
          </p>

          <pre>
            loop:
                // if user types fast, we only care about last event
                event = last(getKeyUp()) 

                text = input.text
                minLength = text.length > 2

                if (minLength & text != previousText):
                    data = searchWikipedia(text) 
                    if (data.error) 
                        showError(data.error)
                    else 
                        showResults(data)
                else if not minLength:
                    clearResults()

                previousText = text
          </pre>

          This looks like it might do the job, but implementing this in JavaScript
          requires us to deal with callbacks and it is not clear how that can be fitted
          into the above pseudocode, without obscuring the <b>essence</b> of the solution.

        </div>
      </div>

      <div id="detour" class="panel panel-info">
        <div class="panel-heading">
          <h4>4. detour: goroutines + channels</h4>
        </div>

        <div class="panel-body">
          <p>
            One of the problems with callbacks/events is that they intertwine communcation
            and control flow. This makes it difficult to synchronize between two asynchronous
            code blocks.
          </p>

          <p>
            There are solutions to make callback code cleaner (Promises, Rx/Observables, FRP, etc.)
            but they don't change the fundamental nature of events.
            Moreover, these solutions introduce new (proprietary)
            mechanisms for control flow, including error handling,
            (e.g. <i>then</i>, <i>all</i>, <i>distinctUntilChanged</i>, etc.),
            even though control flow already exists at the language level! 
          </p>

          <p>
            It turns out there is another way.
          </p>

          <p>
            The Go programming language provides Goroutines and Channels for building
            concurrent systems. Goroutines execute concurrently with other goroutines and
            channels provide a means for two goroutines to communicate & synchronize.
          </p>

        </div>
      </div>

      <div id="solution" class="panel panel-primary">
        <div class="panel-heading">
          <h4>5. solution</h4>
        </div>

        <div class="panel-body">

          <p>
            Goroutines and Channels make it possible to write straightforward async
            code that is easy to follow using standard JavaScript control flow constructs,
            including those for error handling (try/catch).
          </p>

          <blockquote>
            To implement goroutines and channels in JavaScript, async.es relies on Generators, which
            is a new language feature in ES6. For it to work in current browsers, we use Google Traceur
            to transpile ES6 on the fly to ES5 (you can also transpile code as part of your build process).
          </blockquote>

          <p>
            Let's step through the code.
          </p>


          <div class="row">
            <div class="col-md-8">
              <pre>
    var input = document.getElementById('searchtext'),
        results = document.getElementById('results');

    function clearResults() {
        results.innerHTML = '';
    }

    function showResults(terms) {
        var i, len, p;

        clearResults();
        
        for (i = 0, len = terms.length; i < len; i++) {
            p = document.createElement('p');
            p.innerHTML = terms[i];
            results.appendChild(p);
        }                
    }

    function showError(err) {
        results.innerHTML = '<h1p>Error:</h1>' + err;
    }

              </pre>
            </div>

            <div class="col-md-4">
              These functions display the results. Nothing unusual here.
            </div>
          </div>


          <div class="row">

            <div class="col-md-8">

              <pre class="condensed">
function searchWikipedia(term) {
    var url = 'http://en.wikipedia.org/w/api.php?' +
              'action=opensearch&format=json&callback=?&search=' +
              encodeURIComponent(term);
    return jsonp(url);
}                
              </pre>

            </div>

            <div class="col-md-4">
              The <code>searchWikipedia</code> function returns a channel that will get results
              from the specified jsonp request. The channel is created by calling the <code>jsonp</code> utility function in async.es.
            </div>              
          </div>


          <div class="row">
            <div class="col-md-8">
              <pre>

    go(function* () {
       var  keyup = listen(input, 'keyup'),
            pacedKeyup = pace(keyup, 300),
            evt, data, res, text, previousText,
            minLength;
        
        while (true) {
            evt = yield pacedKeyup.get();
            text = evt.target.value;
            minLength = text.length > 2;

            if (minLength && text !== previousText) {
                data = yield searchWikipedia(text).get();
                
                if (data.error) {
                    showError(JSON.stringify(data.error));
                } else {                    
                    if (data[0] && data[1]) {
                        showResults(data[1]);
                    }
                }
                
            } else if (!minLength) {
                clearResults();
            }

            previousText = text;
        }
    });

              </pre>
            </div>

            <div class="col-md-4">
              <p>
                We kick off a goroutine by calling <code>go(someFunction)</code>.
              </p>

              <p>
                In the goroutine, we create a channel with <code>listen</code>on which we'll receive
                keyup events. We pipe that channel through <code>pace</code> so that
                if the user types faster than 300ms, we don't get bombarded.
              </p>

              <p>
                Now for some interesting bits. We create a <code>while (true)</code> loop (afterall,
                the user must be able enter text an infinite number of times).
              </p>

              <p>
                Next we <b>wait</b> for a keyup event in the channel: <code>yield pacedKeyup.get()</code>.                
              </p>

              <p>
                Once we receive a keyup event, we do some checking to make sure it passes constraints
                like minimum length etc.
              </p>

              <p>
                Finally we shoot a request to the Wikipedia API and once again <b>wait</b> for the results <code>yield searchWikipedia(text).get()</code>
                Again, we can halt execution of the current goroutine because other goroutines
                run concurrently, meaning the rest of the program remains responsive.
              </p>
                
            </div>


          </div>


        </div>
        
        
      </div>

    </div>

    <a href="https://github.com/async-es/async-es"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>


    <script src="async-es.js" type="text/traceur"></script>
    <script src="autocomplete.js" type="text/traceur"></script>
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>    
  </body>

</html>
